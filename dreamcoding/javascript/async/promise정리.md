# Promise

## Promise 개념부터 활용까지

`promise`는 자바스크립트에서 제공하는 비동기를 간편하게 처리할 수 있도록 도와주는 object이다. 이 프라미스는 정해진 장시간에 기능을 수행하고나서 정상적으로 기능이 수행이 되어졌다면 성공의 메세지와 함게 처리된 결과값을 전달해주고 만약 기능을 수행하다가 예상치 못한 문제가 발생했다면 에러를 전달해준다.

<br/>

## Promise

`promise`는 자바스크립트 안에 내장되어있는 object이다. 이 object는 asynchronous operation을 위해 사용된다. 즉,비동기적인 것을 수행할 때 콜백함수 대신 유용하게 쓸 수 있는 그런 object인 것이다. 이 `promise`는 딱 두 가지만 포인트 잡고 공부하면 되다.

첫 번째는 state, 상태. 이 프로세스가 무거운 operation을 수행하고있는 중인지 아니면 이 기능 수행이 다 완료가 되어서 성공했는지 실패했는지,  이런 상태에 대해서 이해하는 것이 중요하다.
그리고 두번 째는 producer와 consumer의 차이점을 아는 것이다. 우리가 원하는 데이터를 프로듀싱 = 제공하는 사람과 이 제공된 데이터를 쓰는 사람 = 필요한사람 = consumer. 이 두 가지의 차이점을 알면 좋다. 그래서 정보를 제공하는 프로듀서와 이 정보를 소비하는 소비자의 두 가지  견해를 이해하면 좋을 것 같다. 이것을 염두에 두고 한번 알아보도록 하자.



### state
`promise`의 상태는 `promise`가 만들어져서 우리가 지정한 operation이 수행중일 때는 **pending**상태가 되고, 이 operation을 성공적으로 끝내게 되면 **fulfilled**상태가 된다. fulfilled는 완벽하게 완료된 상태를 말한다.
반대로 파일을 찾을 수 없거나 네트워크에 문제가 생기면 **rejected** 상태가 된다.


### producer & consumer
`promise`에는 우리가 원하는 기능을 수행해서 해당하는 데이터를 만들어내는 **producer**(promise object)와 우리가 원하는 데이터를 소비하는 **consumer**로 나누어진다.


<br/>

## promise 만들어보기

  > 우리가 원하는 기능을 비동기적으로 실행하는 프로미스를 만들어보자.
```js
const promise = new Promise((resolve, reject) => {
  //doing some heavy work (network, read files)
  console.log("doing something ...");
})
```

<br/>

`promise`는 클래스이다. 그래서 `new`라는 키워드를 이용해 object를 생성할 수 있다. 이 `promise`의 생성자를 보면 `executor`라는 콜백 함수를 전달해줘야 하는데 이 콜백함수에는 또 다른 두가지의 콜백함수를 받는다. 바로 기능을 정상적으로 수행해서 마지막에 최종 데이터를 전달하는 `resolve` 콜백함수와 기능을 수행하다가 중간에 문제가 생기면 호출하게되는 `reject` 콜백함수 이 두가지로 나누어져있는 걸 확인할 수 있다. 그래서 두 가지 `resolve` 또는 `reject`를 받는 `executor` 콜백 함수를 만들면 된다. 이렇게만 하면 `promise objecct`를 만들 수 있다.

보통은 `promise` 안에서 조금 헤비한 일들을 한다. 왜냐하면 우리가 네트워크에서 데이터를 받아오거나 파일에서 무언가 큰 데이터를 읽어오는 그런 과정은 시간이 꽤 걸리는데, 그런 작업을 동기적으로 처리하게 되면 우리가 파일을 읽어오고 네트워크에서 데이터를 받아오는 동안 그 다음 라인에 코드가 실행되지 않기 때문에 시간이 조금 걸리는 일들은 이렇게 `promise`를 만들어서 비동기적으로 처리하는 것이 좋다. 그래서 네트워크통신을 하던지 파읠을 읽어서 온다던지 이런 작업들은 다 비동기적으로 처리한느 것이 좋다.

<br/>

### 위 예제로 알 수 있는 점.
> 새로운 `promise`가 만들어질 때는 우리가 전달한 `executor`라는 함수가 바로 실행이 된다. (자동적으로)

`promise`를 만드는 순간 우리가 전달한 `executor`라는 콜백함수가 바로 실행이 되는 것을 확인할 수 있다. 만약 우리가 `promise` 안에 네트워크 통신을 하는 그런 코드를 작성했다면 `promise`가 만들어지는 그 순간 바로 네트워크 통신을 수행하게 된다.

여기서 한가지 우리가 배울 수 있는 중요한 포인트는 만약 네트워크 요청을 사용자가 요구했을때만 해야 되는 경우라면 즉, 사용자가 버튼을 눌렀을 때 네트워크 요청을 해야 되는 경우에는 이런식으로 코드를 작성하면 사용자가 요구하지도 않은 불필요한 네트워크 통신이 일어날 수 있다. 그래서 `promise`를 만드는 순간 그 안에 전달된 `executor`라는 콜백함수가 바로 실행된다는 점을 유의해서 공부해야한다. 이걸 간과하면 불필요한 네트워크 통신을 하게 될 수도 있다. 

## promise 사용하기 (consumer)
> Consumers: then, catch, finally

```js
promise
  .then(value => {
  console.log(value); //ellie
  //proomise가 정상적으로 잘 수행이 되어서 최종적으로 resolve라는 콜백함수를 통해서 전달된 값이 이 value의 파라미터로 전달되어 들어온다. 
  //resolve가 아닌 reject를 사용했을땐?
  // > promise.js:21 Uncaught (in promise) Error: no network at promise.js:21:12
})
  .catch(error => {
  console.log(error);
  // > Error: no network at promise.js:21:12
})
  .finally(()=>{
    console.log('finally');
  })
```

<br/>

error handling을 잘하는 방법.
//첫번째 우리가 프로미스에서 덴이라는 api를 이용해서 성공적인 케이스를 잘다뤘다면 캐치라는 이 함수를 이용해서 에러가 발생했을 때 어떻게 처리할건지 콜백함 수를 등록해주면 된다. 
//이렇게하면 더이상 에러가 발생하지 않고 우리가 받아온 에러가 콘솔로그에 출력되는 걸 확인할 수 있음.
//프라미스의 then을 호출하게 되면 then은 결국 똑같은 promise를 리턴하기 대문에 그 리턴된 프로미스의 캐치를 다시 호출할 수 있게 되는 것임. 이것을 체이닝이라고 함. 프라미스에서도 then을 호출하게되면 다시 promise가 리턴이 되고 리턴된 프로미스에 캐치를 등록하는 것임. 
//promise object를 만들때 우리가 비동기적으로 수행하고 싶은 그런 기능들의 코드를 여기에 작성하고 나서 성공적으로 잘했다면 리졸브를 호출하게 되고 실패했다면 이렇게 실패한 것과 왜 실패했는지 에러를 전달하게 된다. 나중에 이 프로미스ㅡ, 덴관 캐치를 이용해서 성공한 값, 실패한 에러를 받아ㅘ 우리가 원하ㅡㄴ 방식으로 처래후져몬 됨 최근에 추가된건 finally 이건 성공하듯 실패하든 상관없이 무조건 마지막에 호출되어지는 아이임. 아무런 인자를 받지않고 콘솔로그를 출력하게 되면. 실패했을때도 에러콜백함수가 처리되고 나서 파이널리가 호출되는 걸 확인할 수 있음. 만약 여기 위에서 성공한 리졸브를 쓰게돼도, 성공적인 콜백함수가 수행이 되고 나서 다시 파이널리가 무조건 수행되는걸 확인할 수 있다. 그래서 성공흐단 실패하든 상관없이 어떤 기능을 마지막으로 수행하고 싶을 때 그 때 파이널ㄹ리를 사용할 수 있으.ㅁ 


<br/>
<br/>
<br/>
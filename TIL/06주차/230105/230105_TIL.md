# 01월 05일 - 메서드와 this, 클로저, 옵셔널 체이닝 '?.',String, 배열

<br>

✨ 범쌤


📋 오늘의 목표

✅ TIL 작성 및 수업 복습

🟩 JS 코테 풀기

🟩 JS 코어 읽기

🟩 BOJ 연습하기

🟩 8시반 회고

<br/>
<br/>

## 📝 **Today I Learned**

<br/>

## 1. 메서드와 this

### 메서드 만들기

객체 `user`에게 인사할 수 있는 능력을 부여

```js
let user = {
  name: "John",
  age: 30
};

user.sayHi = function() {
  alert("안녕하세요!");
};

user.sayHi(); // 안녕하세요!
```
<br/>

함수 표현식으로 함수를 만들고, 객체 프로퍼티 `user.sayHi`에 함수를 할당했다. 이제 객체에 할당된 함수를 호출하면 `user`가 인사를 해준다. 이렇게 **객체 프로퍼티에 할당된 함수를 메서드(method)** 라고 부른다.

메서드는 아래와 같이 이미 정의된 함수를 이용해서도 만들수도 있다.
<br/>

```js
let user = {
  // ...
};

// 함수 선언
function sayHi() {
  alert("안녕하세요!");
};

// 선언된 함수를 메서드로 등록
user.sayHi = sayHi;

user.sayHi(); // 안녕하세요!
```

<br/>

> 여기서 중요한 점. 함수를 호출하지 않고, 함수 그 자체를 등록한 것. 호출하고 넣으면 함수의 반환값(실행결과)이 들어간다.

<br/>
<br/>

    💡 객체 지향 프로그래밍
    객체를 사용하여 개체를 표현하는 방식을 객체 지향 프로그래밍(object-oriented programming, OOP)이라 부릅니다.
    (Instance Method, Static Method가 객체지향과 관련된 내용임.)

<br/>
<br/>

### 메서드 단축 구문
가장 많이 사용되는 방법이다. 객체 리터럴 안에 메서드를 선언할 때 사용할 수 있는 단축 문법이다.

<br/>

```js
// 아래 두 객체는 동일하게 동작합니다.

user = {
  sayHi: function() {
    alert("Hello");
  }
};

// 단축 구문을 사용하니 더 깔끔해 보이네요.
user = {
  sayHi() { // "sayHi: function()"과 동일합니다.
    alert("Hello");
  }
};
```

<br/>

위처럼 `function`을 생략해도 메서드를 정의할 수 있다. (": function"을 날림) 이렇게 선언해도 똑같이 함수 선언문으로 선언한 함수가 된다. (화살표 함수와 다르다.) 

자세히 구조를 살펴보면 미묘한 차이가 존재한다. `constructor`를 내장하냐 안하냐에 차이인데, 위 방식으로 만든 메서드는 `constructor`를 내장하지 않는다. 이런 메서드를 `concise method`라고 부른다. 일반 함수와 다르게 `constructor`를 내장하고 있지 않기 때문에 훨씬 가볍고 성능적으로도 이점을 가져온다.

<br/>
<br/>

### 메서드와 this
메서드는 객체에 저장된 정보에 접근할 수 있어야 제 역할을 할 수 있다. 모든 메서드가 그런건 아니지만, 대부분의 메서드가 객체 프로퍼티의 값을 활용한다.


`user.sayHi()`의 내부 코드에서 객체 `user`에 저장된 이름(name)을 이용해 인사말을 만드는 경우가 이런 경우에 속한다. **메서드 내부에서 `this` 키워드를 사용하면 객체에 접근할 수 있다.** 

이때 '점 앞’의 `this`는 객체를 나타냅니다. **정확히는 메서드를 호출할 때 사용된 객체를 나타낸다.**

<br/>

```js
let user = {
  name: "John",
  age: 30,

  sayHi() {
    // 'this'는 '현재 객체'를 나타냅니다. = user
    alert(this.name);
  }

};

user.sayHi(); // John = sayHi()를 호출한 객체가 user임.
```

<br/>

일반함수는 `this`를 갖지만 화살표 함수는 `this`를 갖고 있지 않아서, 부모(상위요소)의 `this`를 찾아서 가져온다.

<br/>

```js
let user = {
  name: "John",
  age: 30,

  sayHi : () => {
    // 화살표 함수의 this는 따로 없음. 그래서 부모의 this를 가져옴.
    alert(this.name); //부모(=user)의 this인 window를 가져와서 this로 할당함.
  }

};

user.sayHi(); // 누가 호출했냐는 상관없음
```

<br/>

> 객체의 메서드로 함수를 정의할 경우에는 일반 함수를 사용하는 것이 좋다. 화살표 함수는 `this`를 찾지 못하는 문제가 있기 때문이다.

<br/>
<br/>

### 자유로운 this
자바스크립트에서는 모든 함수에 `this`를 사용할 수 있다. `this` 값은 런타임 때 결정된다. 정확히 말하자면, 컨텍스트에 따라 달라진다. 동일한 함수라도 다른 객체에서 호출하면 `this`가 참조하는 값이 달라진다.

함수가 호출되면 함수 실행컨텍스트가 생성된다. 즉, 함수가 호출될 때 `this`가 결정된다.


<br/>
<br/>

### 객체없이 호출하기 : `this == undefined`

객체가 없어도 함수를 호출할 수 있다. 

```js
'user strict'

function sayHi() {
  alert(this);
}

sayHi(); // undefined
```

엄격모드에서 위 코드를 실행하면 `this`엔 `undefined`가 할당된다. 엄격모드가 아닐 땐 `this`가 *전역객체* 를 참조한다. 브라우저 환경에선 `window`라는 전역객체를 참조한다. 이 동작의 차이가 "use strict"가 도입된 배경이기도 하다. 

<br/>
<br/>

### this가 없는 화살표 함수
화살표 함수는 일반 함수와 달리 고유한 `this`를 가지지 않는다. 화살표 함수에서 `this`를 참조하면, 화살표 함수가 아닌 '평범한' 외부 함수에서 `this`를 가져온다.

아래 코드에서 함수 `arrow()`의 `this`는 외부 함수 `user.sayHi()`의 `this`가 된다.

```js
let user = {
  firstName: "보라",
  sayHi() {
    let arrow = () => alert(this.firstName); //user.sayHi()의 this는 user임. 그래서 user의 firsName을 가져옴.
    arrow(); //일반함수로 호출돼서 여기서 this는 user.sayHi()의 this임. (부모의 this)
  }
};

user.sayHi(); // 보라
```
<br/>

메서드 안에서 함수를 선언해야 할 경우엔 화살표 함수가 좋다. (위 코드)

<br/>
<br/>

### 요약
- 객체 프로퍼티에 저장된 함수를 '메서드'라고 부른다.
- 메서드는 `this`로 객체를 참조한다.

`this` 값은 런타임에 결정된다.
- 함수를 선언할 때 `this`를 사용할 수 있다. 다만, 함수가 호출되기 전까지 `this`엔 값이 할당되지 않는다.
- 함수를 복사해 객체 간 전달할 수 있다.
- 함수를 객체 프로퍼티에 저장해 `object.method()`같이 '메서드' 형태로 호출하면 `this`는 `object`를 참조한다.
- 화살표 함수는 자신만의 `this`를 가지지 않는다는 점에서 독특한데, 화살표 함수 안에서 `this`를 사용하면 외부에서 `this` 값을 가져온다.


<br/>
<br/>

### 예제

<br/>

올라가기(`up`)와 내려가기(`down`) 메서드를 제공하는 객체 `ladder`가 있다.

```js
let ladder = {
  step: 0,
  up() {
    this.step++; //ladder
  },
  down() {
    this.step--; //ladder
  },
  showStep() {
    // 사다리에서 몇 번째 단에 올라와 있는지 보여줌
    console.log(this.step); //ladder
  },
};
```

<br/>

`up`, `down`, `showStep`을 수정해 아래처럼 메서드 호출 체이닝이 가능하도록 해보자.

```js
ladder.up().up().down().showStep(); // 1
```

    ladder.up().up().down().showStep(); 가 실행되도록.
    ladder.up()이 this(=ladder)를 반환하면
    ladder.up().down().showStep();
    또 this(=ladder)를 반환하면
    ladder.down().showStep();
    반복 => 즉 각각 메서드가 this(=ladder)를 리턴하면 됨.


<br/>

```js
let ladder = {
  step: 0,
  up() {
    this.step++; //ladder
    return this
  },
  down() {
    this.step--; //ladder
    return this
  },
  showStep() {
    // 사다리에서 몇 번째 단에 올라와 있는지 보여줌
    console.log(this.step); //ladder
    return this
  },
};
```

<br/>

    ladder.up().up().down().showStep(); 가 실행되도록.
    ladder.up()이 this(=ladder)를 반환하면
    ladder.up().down().showStep();
    또 this(=ladder)를 반환하면
    ladder.down().showStep();
    반복 => 즉 각각 메서드가 this(=ladder)를 리턴하면 됨.

<br/>

#### 최종 코드
```js
let ladder = {
  step: 0,
  up() {
    this.step++; //ladder
    return this
  },
  down() {
    this.step--; //ladder
    return this
  },
  showStep() {
    // 사다리에서 몇 번째 단에 올라와 있는지 보여줌
    console.log(this.step); //ladder
    return this
  },
};
```

<br/>

> 이런 방법을 가장 잘 활용하는 라이브러리가 바로 `jQuery`임.

<br/>
<br/>

메서드 자체의 리턴 값을 자신의 객체를 가리키는 `this`로 해주어 객체.메소드() 형태를 체인형태로 유지시켜줌.

<br/>

```js
// 매장 주문의 결제 금액 총 합을 구하는 메서드를 구현해봅니다.
const shopOrder = {
  date: "2022. 7. 6",
  tableIndex: 5,
  menu: [
    //배열
    { name: "통 새우 돈까스", price: 13000, count: 2 },
    { name: "치즈 돈까스", price: 10000, count: 1 },
  ],
  totalPrice() {
    // console.log(this.menu[0].price * this.menu[0].count); //this는 shopOrder

    //acc에 더해지는 건 +=와 같음.
    return this.menu.reduce((acc, cur) => acc + cur.price * cur.count, 0);
  },
};

// shopOrder.totalPrice(); //totalPrice()의 this는 shopOrder

console.log(shopOrder.totalPrice()); //360000
```

<br/>
<br/>

## 2. 클로저
- 스코프의 정의 : 이름(변수)의 유효 범위
- 렉시컬 스코프 : 정적 스코프라고도 불린다. 동적 스코프의 단점 때문에 등장한 개념.

<br/>
<br/>

```js
function first () {
  let x = 10;

    function second () {
      let y = 30;
      return x + y;
    }
  
    return second //함수 실행이 아니라, 함수 자체를 리턴.
}

console.log(first()); //second 함수 자체가 콘솔에 찍힘.
```

<br/>

**자바스크립트는 함수를 값으로 인식한다.** 결국 `first`함수를 실행하면 `second`함수 전체가 튀어나온다. `second`함수까지 실행하기 위해서는 `first()()`를 하면 되다. `first()`자체가 `second`함수 이기 때문이다. 

<br/>

`console.log(first()()); >> 40`

<br/>
<br/>

> 클로저를 사용하는 이유 = 전역의 오염을 막기 위해

<br/>
<br/>

```js
function number() {
  let count = 0;

  function inner() {
    return ++count;
  }

  return inner 
}

const counter = number(); //inner함수 전체

//count를 못가져옴 > 오염될 일이 없음. 접근 불가능. 스코프가 때문.
// console.log(count);
```

<br/>
<br/>

## 3. 옵셔널 체이닝 `?.`
옵셔널 체니닝을 사용하면 프로퍼티가 없는 중첩 객체를 에러없이 안전하게 접근할 수 있다. `?.`은 `?.`'앞’의 평가 대상이 `undefined`나 `null`이면 평가를  멈추고 `undefined`를 반환한다.

**설명이 장황해지지 않도록 지금부턴 평가후 결과가 `null`이나 `undefined`가 아닌 경우엔 값이 ‘있다’ 혹은 '존재한다’라고 표현하겠습니다.**

<br/>

```js
let user = {}; // 주소 정보가 없는 사용자

alert( user?.address?.street ); // undefined, 에러가 발생하지 않습니다.
```

<br/>

`user?.address`로 주소를 읽으면 아래와 같이 `user`객체가 존재하지 않더라도 에러가 발생하지 않는다.

<br/>

```js
let user = null;

alert( user?.address ); // undefined
alert( user?.address.street ); // undefined
```

<br/>

> 남용하면 안된다. 있어도 되고, 없어도 되는 정도의 애들에게만 사용!

<br/>
<br/>

- `?.`은 연산자가 아니다. `?.`은 함수나 대괄호와 함께 동작하는 특별한 문법 구조체(syntax construct)이다.


#### 한 객체엔 메서드 `admin`이 있지만 다른 객체엔 없는 상황

```js
let user1 = {
  admin() {
    alert("관리자 계정입니다.");
  }
}

let user2 = {};

user1.admin?.(); // 관리자 계정입니다.
user2.admin?.();
```

<br/>

두 상황 모두에서 user 객체는 존재하기 때문에 `admin` 프로퍼티는 `.`만 사용해 접근했다. 그리고 난 후 `?.()`를 사용해 `admin`의 존재 여부를 확인했다. `user1`엔 `admin`이 정의되어 있기 때문에 메서드가 제대로 호출되었다. 반면 `user2`엔 `admin`이 정의되어 있지 않았음에도 불구하고 메서드를 호출하면 에러 없이 그냥 평가가 멈추는 것을 확인할 수 있다.

<br/>
<br/>

- `.`대신 대괄호 `[]`를 사용해 객체 프로퍼티에 접근하는 경우엔 `?.[]`를 사용할 수도 있다.
- `?.`은 `?.`왼쪽 평가대상이 없어도 괜찮은 경우에만 선택적으로 사용해야 한다. 꼭 있어야 하는 값인데 없는 경우에 `?.`을 사용하면 프로그래밍 에러를 쉽게 찾을 수 없으므로 이런 상황을 만들지 말도록 해야 한다.

<br/>
<br/>

### 🙋🏻‍♀️ 오늘의 질문

<br/>

### 🔖 참고자료

<br/>
<br/>

## 기억에 남는 말 💬

<br/>
<br/>

## 코멘트 🎈

<br/>
